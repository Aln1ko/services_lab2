version: '3.8'

services:
   gateway:
    build:
      context: . 
      # 2. Вказуємо Dockerfile, який знаходиться всередині папки сервісу
      dockerfile: ./gateaway/Dockerfile
    ports:
      - "8000:8000"
    depends_on:
      - auth-service
      - subscription-service
      - board-service
      - task-service
      - notification-service
    restart: always

   auth-service:
    build:
      context: . 
      # 2. Вказуємо Dockerfile, який знаходиться всередині папки сервісу
      dockerfile: ./auth_service/Dockerfile
    
    expose:
      - "8000"
    
    volumes:
      - ./auth_service:/app
      - ./shared:/app/shared
    # Поточна папка на комп'ютері → папка /app в контейнері
    # Зміни в коді будуть відображатись автоматично (hot reload)
    
    environment:
      - ENVIRONMENT=development
    # Встановлює змінну оточення ENVIRONMENT=development
    # В коді можна отримати її через os.getenv('ENVIRONMENT')
    restart: always

   subscription-service:
    build:
      context: . 
      # 2. Вказуємо Dockerfile, який знаходиться всередині папки сервісу
      dockerfile: ./subscription_service/Dockerfile

    expose:
      - "8000"

    volumes:
      - ./subscription_service:/app  
      - ./shared:/app/shared

    environment:
      - ENVIRONMENT=development

    restart: always

    depends_on:
      - auth-service

   board-service:
    build:
      context: . 
      # 2. Вказуємо Dockerfile, який знаходиться всередині папки сервісу
      dockerfile: ./board_service/Dockerfile
    expose:
      - "8000"
    
    volumes:
      - ./board_service:/app  
      - ./shared:/app/shared

    environment:
      - ENVIRONMENT=development

    restart: always
    depends_on:
      - auth-service
    
   task-service:
    build:
      context: . 
      # 2. Вказуємо Dockerfile, який знаходиться всередині папки сервісу
      dockerfile: ./task_service/Dockerfile
    expose:
      - "8000"
    volumes:
      - ./task_service:/app  
      - ./shared:/app/shared

    environment:
      - ENVIRONMENT=development
    restart: always
    depends_on:
      - auth-service
      - board-service
  
   notification-service:
    build:
      context: . 
      # 2. Вказуємо Dockerfile, який знаходиться всередині папки сервісу
      dockerfile: ./notification_service/Dockerfile
    expose:
      - "8000"
    volumes:
      - ./notification_service:/app  
      - ./shared:/app/shared

    environment:
      - ENVIRONMENT=development
      - PYTHONPATH=/app

    restart: always
    depends_on:
      rabbitmq:
        condition: service_healthy

   rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    ports:
      - "5672:5672"   # порт для додатків (Python)
      - "15672:15672" # веб-інтерфейс (http://localhost:15672)
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    restart: always
    healthcheck: # <-- Додаємо перевірку здоров'я
      test: ["CMD", "rabbitmq-diagnostics", "check_port_connectivity"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s # Даємо час на старт


   keycloak:
    image: quay.io/keycloak/keycloak:23.0.0
    command: start-dev
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: password
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
    ports:
      - "8080:8080"
    depends_on:
      - postgres
  
   postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: keycloak
      POSTGRES_USER: keycloak
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    
   postgres_exporter:
    image: prometheuscommunity/postgres-exporter:latest
    container_name: postgres_exporter
    environment:
      # Налаштування підключення до вашого сервісу 'postgres'
      DATA_SOURCE_NAME: "postgresql://keycloak:password@postgres:5432/keycloak?sslmode=disable"
    expose:
      - "9187" # Порт для експортера
    depends_on:
      - postgres
    restart: always

   prometheus:
    image: prom/prometheus
    container_name: prometheus
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
    ports:
      - "9090:9090"
    depends_on:
      # - gateway
      - auth-service
      # - subscription-service
      # - board-service
      # - task-service
      # - notification-service

   grafana:
    image: grafana/grafana
    container_name: grafana
    ports:
      - "3000:3000"
    volumes:
      - grafana-storage:/var/lib/grafana
    depends_on:
      - prometheus
  
   jaeger:
    image: jaegertracing/all-in-one:latest
    container_name: jaeger
    ports:
      # 16686: Веб-інтерфейс Jaeger UI (http://localhost:16686)
      - "16686:16686" 
      # 4318: Порт OTLP HTTP (OpenTelemetry Protocol) для експорту трас
      - "4318:4318"  
    environment:
      # Ця змінна дозволяє Jaeger приймати траси через OTLP HTTP
      - COLLECTOR_OTLP_ENABLED=true
    restart: always

volumes:
  grafana-storage:
  postgres_data: